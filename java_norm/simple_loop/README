
Java Normalization and Author Identification
Paul deGrandis

This is a simple example of one approach to Java normalization and
what kind of information can be extracted.

Directories:
 :: build - this holds intermediate files during the construction process
             (class files, assembly files)
 :: src - the simple loop java source files
 :: util - extra utilites for processing and comparing normalized Java Files
    :: cocoa - utilites written in cocoa (cross platform with GNUstep)
	:: objc - utilities written in vanilla objective c.  Works with gcc.
	:: py - utilities written in python	
 :: xcode - an xcode project for those who like to use it
 
Dependencies:
 You'll need Java 1.1+, Python 2.1+, gcc, and optionally Cocoa or GNUstep

Getting Started:
 To get started type:
   make
 This will compile the java source files to class files and generate the 
 Java assembly files.
 It will then take the assembly files, convert them to source files, and
 generate class files at every stage for comparison
 To compare two "normalized" assembly files, type:
   python util/py/JasmProcessor.py build/asm/SimpleFor.j build/asm/SimpleWhile.j

Process:
 Take a look at the source code directory (src).  In it you'll find three files
 all containing a simple loop that prints "Hello World" 10 times.
 These files are compiled to java class files.  The class files are then
 processed using bcel and JasminVisitor and Java Assembly code is generated.
 The JASM code is considered an intermediate and normalized version of Java
 source code because certain semantic contructs (like looping) are reduced to
 a single construct.  This code is further normalized and processed using
 the JasmProcessor.py file, which removes parts of the code that are syntactic
 sugar in JASM code.
 At this stage, comparison and metrics can be calculated.  Currently only one
 exists as a proof of concept and that is Longest Common Sequence and
 Longest Common Substring.
 
 A similarity metric is generated by the following equation:
 Percent Similar = 
    (Length of LCSeq/Length of Sequence One) + (Length of LCSeq/Len Seq Two)/2

 This is the arithmetic mean (average) of the percentage that LCS makes up the
 individual sequences.
 An "exact match" percentage metric is generated by subsituting the LCSubstring
 for LCSequence above.

 In addition to the JASM files, we also generate the source equivlant of
 the JASM files for comparison against the original source.  This equivlant
 source, the original source, and the JASM files are all compiled to java
 class files for class based comparison.

Future Work:
 This is only one approach in one avenue.  Other intermediate forms
 be generated and compared.  Still left to do in this approach is
 a more robust comparison.  This includes ordering functions smallest
 to largest, because currently, changing the order of functions, tampers
 with the normalization comparison.  Also, optimized versions of algorithms
 such as LCS should be generated.

 Other avenues also include source-to-source transformation and
 comparison using TXL.  This has some attractive advantages that
 be discussed further in that proof of concept demo.

Paul
